---
import type { Post, PostMeta } from "@/lib/blog/types"
import Icon from "@/components/base/Icon.astro"
import SubpostCountBadge from "@/components/blog/SubpostCountBadge.astro"
import SubpostNavItem from "@/components/blog/SubpostNavItem.astro"
import SubpostsList from "@/components/blog/SubpostsList.astro"
import { ScrollArea } from "@/components/ui/scroll-area"

interface Props {
  currentPost: Post
  parentPost?: Post | null
  subposts?: PostMeta[]
  isSubpost?: boolean
  activePost: PostMeta
}

const { currentPost, parentPost, subposts = [], isSubpost = false, activePost } = Astro.props

const activePostData = parentPost || currentPost
const isActivePost = activePostData.id === currentPost.id
const currentSubpostDetails = isSubpost
  ? subposts.find((subpost) => subpost.id === currentPost.id) || null
  : null
const currentTitle = currentSubpostDetails?.title || activePostData.data.title
const subpostCount = subposts.length
---

{
  activePost && subpostCount > 0 && (
    <nav id="mobile-subposts-container" class="w-full xl:hidden" aria-label="Subposts navigation">
      <details class="group" role="button" aria-expanded="false">
        <summary class="mx-auto flex w-full max-w-3xl cursor-pointer items-center justify-between px-4 py-3">
          <div class="flex min-w-0 items-center gap-2">
            <Icon
              name="post-active"
              class="text-primary size-5 flex-shrink-0"
              aria-label={isSubpost ? "Active subpost" : "Active post"}
            />
            <span class="text-foreground min-w-0 truncate text-sm leading-tight font-medium">
              {currentTitle}
            </span>
            {subpostCount && !isSubpost && (
              <SubpostCountBadge count={subpostCount} variant="full" />
            )}
          </div>
          <Icon
            name="chevron-down"
            class:list={[
              "text-muted-foreground size-4 flex-shrink-0",
              "transition-transform duration-200 group-open:rotate-180"
            ]}
          />
        </summary>

        <div class="border-border/50 mx-auto max-w-3xl border-t" data-scroll-container>
          <ScrollArea
            client:load
            className="flex max-h-[30vh] flex-col overflow-y-auto"
            data-scroll-area
          >
            <div class="flex list-none flex-col gap-y-1 px-3 py-2">
              {activePost && (
                <SubpostNavItem post={activePost} isActive={isActivePost} isSubpost={false} />
              )}

              <SubpostsList subposts={subposts} currentPostId={currentPost.id} />
            </div>
          </ScrollArea>
        </div>
      </details>
    </nav>
  )
}

<script>
  import { BaseTOCController } from "@/lib/blog/scroll"
  import type { ScrollMaskConfig } from "@/lib/blog/types"

  class SubpostsHeaderController extends BaseTOCController {
    private detailsElement: HTMLDetailsElement | null = null

    getContainerSelector() {
      return "#mobile-subposts-container"
    }

    getLinkSelector() {
      return "#mobile-subposts-container a"
    }

    // Override for Radix ScrollArea (uses ScrollArea like sidebars)
    protected getScrollAreaSelector(): string {
      return "[data-radix-scroll-area-viewport]"
    }

    // Override mask classes for different fade effect
    protected getMaskClasses(): ScrollMaskConfig {
      return { top: "mask-t-from-80%", bottom: "mask-b-from-80%" }
    }

    getActiveItemSelector() {
      return "[aria-current='page']"
    }

    protected setupCustomBehavior() {
      const container = document.querySelector(this.getContainerSelector())
      if (!container) return

      this.detailsElement = container.querySelector("details")
      const links = container.querySelectorAll("a")

      if (this.detailsElement) {
        this.detailsElement.addEventListener("toggle", () => {
          if (this.detailsElement?.open) {
            requestAnimationFrame(() => {
              // Find active item and scroll to it
              const activeItem = this.state.scrollArea?.querySelector(this.getActiveItemSelector())
              if (activeItem && this.state.scrollArea) {
                const areaRect = this.state.scrollArea.getBoundingClientRect()
                const itemRect = activeItem.getBoundingClientRect()
                const currentItemTop = itemRect.top - areaRect.top + this.state.scrollArea.scrollTop
                const targetScroll = Math.max(
                  0,
                  Math.min(
                    currentItemTop - (areaRect.height - itemRect.height) / 2,
                    this.state.scrollArea.scrollHeight - this.state.scrollArea.clientHeight
                  )
                )
                this.state.scrollArea.scrollTop = targetScroll
              }
              setTimeout(() => this.tocScrollMask.update(this.getMaskClasses()), 100)
            })
          }
        })
      }

      links.forEach((link) => {
        link.addEventListener("click", () => {
          if (this.detailsElement) this.detailsElement.open = false
        })
      })
    }
  }

  const controller = new SubpostsHeaderController()

  document.addEventListener("astro:page-load", () => controller.init())
  document.addEventListener("astro:after-swap", () => {
    controller.cleanup()
    controller.init()
  })
  document.addEventListener("astro:before-swap", () => controller.cleanup())
</script>
